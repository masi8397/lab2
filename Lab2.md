Lab 2
====

Lab 2 markdown file for written questions 

Name: Michelle Bray

Partner: Marc Simpson

#1. Grammars: Synthetic Examples
	
**a)**	

```
A in AObjects
-------------
A & A in AObjects
		
		
A in AObjects
-------------
V in AObjects
		
		
V in VObjects
-------------
a in Vobjects
		
		
V in Vobjects
-------------
b in Vobjects
```


**b)**	

Given: a & b & b	 

```
			 A
		  /  |  \
		 A   &   A
	   / | \	  \
	  A  &  A	   V
	  |     |      |
	  V		V	   b
	  |     |
	  a		b
	  
	  
			A
		 /  |  \
	    A   &   A
	   /      / | \
	  V      A  &  A
	  |		 |	   |
	  a		 V	   V
			 |	   |
			 b	   b	 
```
	    
It is ambiguous because two different parse trees can be produced from the same grammar.
		
		
**c)**	

```
S ::= A | B | C
A ::= aA | a
B ::= bB | empty
C ::= cC | c
		
S = aA | bB | cC
  = aaA | bbB | ccC
  = aaaaA | bbb | ccccC  
```
		  
This produces a string of form a^n*b^m*c^k, where m >= 0, n > 0, and k > 0
		
		
**d)**	
baab can be generated with this grammar:
	S = AaBb
	S = baBb
	S = baab
		
		
bbbab cannot be generated because of an extra 'a':
	S = AaBb
	S = AbaBb
	S = AbaaBb
		
		
bbaaaaa cannot be generated because we will always end with an 'a'
	S = AaBb
		
		
bbaab can be generated with this grammar: 
	S = AaBb
	S = AbaBb
	S = Abaab
	S = bbaab
		
	
**e)**	
abcd can be generated by the grammar

```
			S
		 / | | \
		a  S c  B
		   |	|
		   b	d
```
		   	
acccbd cannot be generated because the rightmost B cannot produce both a 'b' and 'd' terminal

```
			S
		 / | | \
		a  S c  B
		  / \	
		 c   A
			 |
			 c
```
			 	 
acccbcc cannot be generated because the rightmost B cannot produce 'b' 'c' and 'c'

```
			S
		 / | | \
		a  S c  B
		  / \	
		 c   A
			 |
			 c
```	 
			 
acd cannot be generated because there is no way to produce only 3 terminal symbols
```
			S
		 / | | \
		a  S c  B
```
	
accc can be produced by the grammar
```	
			S
		 / | | \
		a  S c  B
		   |    |
		   A	A
		   |	|
		   c	c 
```  
		   
# 2. Grammars: Understanding A Language

**a)** 
i. The first grammar contains two terminals: operand and operator.
It is left associative because it recurses on the left side,
where the rule is e operator operand.
An example parse tree is (opor = operator and opnd = operand):
```	
				e
			/   |   \
		   e   opor opnd
		/  |  \  
	   e  opor opnd	
	   |
	  opnd
```
The second grammar contains three terminals: operand, operator, and empty.
It is right associative because is recurses on the right side,
(on esuffix  e::= operand esuffix)
An example parse tree is (S = essufix):
```
				e
			  /   \
			opnd   S
			    /  |  \
			 opor opnd S
			        /  |  \  
			     opor opnd S
						   |
						 empty	 
```
ii. These grammars generate the same expression.
They both recurse, the first one on itself and the second through esuffix
Their parse trees return the same terminal symbols, apart from the epsilon
			
	
**b)**	
The '-' operator has precedence over '<<' as seen from the following examples using the scala interpreter 
```
	scala>  10 << 2 - 4
	res15:  Int = -2147483648
	scaka>  10 << -2
	res16:  Int = -2147483648
			
	scala>  10 - 8 << 10
	res17:  Int = 2048
	scala>  2 << 10
	res18:  Int = 2048
```	
				
**c)**	
```
	<float> ::= <sign> <digit> <decimal-point> <digit> <exponent>
	<sign> ::= - | Îµ
	<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
	<decimal-point> ::= .
	<exponent> ::= E <sign> <digit>
```
